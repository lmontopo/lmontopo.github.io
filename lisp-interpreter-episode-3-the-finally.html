<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>Lisp Interpreter: Episode 3 (The Finally!)</title>

    <link rel="stylesheet" href="http://lmontopo.github.io/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://lmontopo.github.io/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://lmontopo.github.io/theme/css/style.css" />
    <link rel="stylesheet" href="http://lmontopo.github.io/theme/css/pygments.css" />	
    <script src="http://lmontopo.github.io/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://lmontopo.github.io">The L Blog</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://lmontopo.github.io/lisp-interpreter-episode-3-the-finally.html" rel="bookmark"
        title="Permalink to Lisp Interpreter: Episode 3 (The Finally!)">Lisp Interpreter: Episode 3 (The Finally!)</a></h3>
    </header>

<h6 class="subheader" title="2014-11-18T05:00:00-05:00">Tue 18 November 2014
</h6>


    <p>Let me start off by apologizing for the delay. I've been hesitant to
write this post for several reasons, including:</p>
<ol>
<li>Presenting and explaining my entire lisp interpreter is a BIG (and
    therefore daunting) task.</li>
<li>There are parts of my code that I'm not entirely satisfied with and
    I <em>may</em> refactor these parts in the future. For this reason, I've
    been debating waiting until I finish refacturing to write this post.</li>
<li>The parts of my code that I'm unsatisfied with are pretty ugly and
    are a pain to read. Which leads me to the next point...</li>
<li>Will anyone actually read this?</li>
</ol>
<p>I have decided to go ahead and write this blog post anyway. Even if no
one reads it, I think that I'll benefit from writing it. As far as the
ugly bits go, I'm trying to not let 'perfect' be the enemy of 'good
enough'. This project is far from perfect but that OK. I worked hard on
it, it works, I learned lots during the process, and those are the
things that matter most. Besides, I've gotten really excited this week
about some other projects, so it could be a while before I get back to
refacturing the interpreter.</p>
<p>OK. Lets get started. Here are the first ten lines of code:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">divisionf</span>
<span class="n">rom</span> <span class="n">termcolor</span> <span class="kn">import</span> <span class="nn">coloredfrom</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">exit</span><span class="c">#------GlOBAL LISTS-----</span>
<span class="o">-</span><span class="n">symbol</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;*&#39;</span><span class="p">,</span> <span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;&lt;&#39;</span><span class="p">,</span>
<span class="s">&#39;&gt;&#39;</span><span class="p">,</span><span class="s">&#39;&lt;=&#39;</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">,</span><span class="s">&#39;&gt;=&#39;</span><span class="p">,</span> <span class="s">&#39;abs&#39;</span><span class="p">,</span> <span class="s">&#39;list&#39;</span><span class="p">,</span> <span class="s">&#39;</span>
<span class="k">if</span><span class="s">&#39;, &#39;</span><span class="ow">not</span><span class="s">&#39;,            &#39;</span><span class="nb">set</span><span class="err">!</span><span class="s">&#39;, &#39;</span><span class="n">begi</span>
<span class="n">n</span><span class="s">&#39;, &#39;</span><span class="n">let</span><span class="s">&#39;, &#39;</span><span class="n">define</span><span class="s">&#39;, &#39;</span><span class="k">lambda</span><span class="s">&#39;, &#39;</span><span class="n">quot</span>
<span class="n">e</span><span class="s">&#39;]special = [&#39;</span><span class="nb">set</span><span class="err">!</span><span class="s">&#39;, &#39;</span><span class="n">begin</span><span class="s">&#39;, &#39;</span><span class="n">let</span><span class="s">&#39;</span>
<span class="p">,</span> <span class="s">&#39;define&#39;</span><span class="p">,</span> <span class="s">&#39;lambda&#39;</span><span class="p">,</span> <span class="s">&#39;cond&#39;</span><span class="p">,</span> <span class="s">&#39;quote</span>
<span class="s">&#39;, &#39;</span><span class="k">if</span><span class="s">&#39;,     &#39;</span><span class="nb">list</span><span class="s">&#39;, &#39;</span><span class="nb">map</span><span class="s">&#39;, &#39;</span><span class="n">cons</span><span class="s">&#39;,</span>
<span class="s">&#39;car&#39;</span><span class="p">,</span> <span class="s">&#39;cdr&#39;</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>The first 3 lines just specify any functions I'll be using from built in
libraries. Next, two important global lists are introduced. The list,
'symbol', specifies strings that have a special meaning and will
therefore be treated differently from other strings of characters. The
list 'special' is a list of all of the built in Scheme functions which
disrupt the flow of the interpretation. All functions, including
addition, subtraction, etc. will be treated in the same way. But our
interpreter will treat these 'special' functions differently.</p>
<p>Next, we introduce my class of exceptions and some instances of that
class:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="c"># --- EXCEPTIONS ---class MyErro</span>
<span class="n">r</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
<span class="n">msg</span><span class="p">):</span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msgif_error</span>
<span class="o">=</span> <span class="n">MyError</span><span class="p">(</span><span class="s">&quot;Error: you need to specif</span>
<span class="n">y</span> <span class="n">by</span> <span class="n">a</span> <span class="n">consequence</span> <span class="ow">and</span> <span class="n">an</span> <span class="n">alternate</span><span class="o">.</span>
<span class="s">&quot;)dict_error = MyError(&quot;</span><span class="n">Error</span><span class="p">:</span> <span class="n">can</span><span class="s">&#39;t</span>
<span class="n">find</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span> <span class="n">Imprope</span>
<span class="n">r</span> <span class="nb">input</span><span class="o">.</span><span class="s">&quot;)unexpected_error = MyError</span>
<span class="p">(</span><span class="s">&#39;Error: unexpectedly entered parse</span>
<span class="n">function</span> <span class="k">with</span> <span class="n">no</span> <span class="nb">input</span><span class="o">.</span><span class="s">&#39;)too_many =</span>
<span class="n">MyError</span><span class="p">(</span><span class="s">&quot;Error: too many arguments w</span>
<span class="n">ere</span> <span class="n">inputed</span><span class="o">.</span><span class="s">&quot;)quote_error = MyError(</span>
<span class="s">&#39;Error: quote only takes one operand</span>
<span class="o">.</span><span class="s">&#39;)let_error = MyError(&#39;</span><span class="n">Error</span><span class="p">:</span> <span class="n">let</span> <span class="n">m</span>
<span class="n">ust</span> <span class="n">be</span> <span class="n">followed</span> <span class="n">by</span> <span class="n">a</span> <span class="nb">list</span><span class="o">.</span><span class="s">&#39;)</span>
</pre></div>
</td></tr></table>

<p>Then, we start doing some of the gritty work: tokenizing and parsing. I
have implemented both my tokenizer and my parser as functions. When we
call them, the output of the tokenizer will be fed as input to my
parser. Here is my tokenizer:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="c"># ---- TOKENIZE ------ def token</span>
<span class="n">izer</span><span class="p">(</span><span class="n">holder</span><span class="p">):</span>    <span class="n">holder</span> <span class="o">=</span> <span class="s">&#39;(&#39;</span> <span class="o">+</span> <span class="n">hold</span>
<span class="n">er</span> <span class="o">+</span> <span class="s">&#39;)&#39;</span>    <span class="n">holder</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
<span class="s">&#39;(&#39;</span> <span class="p">,</span> <span class="s">&#39; ( &#39;</span> <span class="p">)</span>    <span class="n">holder</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="n">re</span>
<span class="n">place</span><span class="p">(</span> <span class="s">&#39;)&#39;</span><span class="p">,</span> <span class="s">&#39; ) &#39;</span> <span class="p">)</span>    <span class="n">final</span> <span class="o">=</span> <span class="n">filte</span>
<span class="n">r</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span>
<span class="s">&#39;))    return final</span>
</pre></div>
</td></tr></table>

<p>The tokenizer takes my user's raw input - something like <code>(+ 2 2)</code>. It
begins by putting extra braces around the entire thing. It then adds
space around all the braces before splitting the input into an array
where each element is a separate token. The input splits over spaces,
which is why it was necessary to add extra space around the braces. far
so good, but why did I begin by adding extra braces?! Seems kind of
wierd, right?</p>
<p>The reason for this seemingly cooky choice was to accomodate inputs like
the following: <code>(define x 3) x</code>. This is a valid Scheme expression which
evaluates to 3. Suppose that I do not add extra brackets around the
entire statement. Then, when I go to actually <em>interpret</em> the input, it
becomes difficult to know when the end of the user input has been
reached. In fact, I did NOT initially add these extra brackets in my
tokenization, but my interpreter evaluated <code>(define x 3) x</code> to be <code>None</code>
instead of <code>3</code>. It simply stopped evaluating after <code>(define x 3)</code>.
Knowing when the end of the user input has been reached, however, is
quite easy if we have an outter set of brackets enclosing everything. Of
course, adding extra brackets came with its own set of issues. I needed
to make sure that my interpreter could differentiate between expressions
like <code>(3)</code> and <code>3</code>. Although '3' is a valid Scheme expression, <code>(3)</code> is
not, and I was essentially changing my input to always look like <code>(3)</code>.
Thanks to Mary Cook, I came up with a pretty clever solution to this
issue, which we will come accross later.</p>
<p>Continuing on... the parser! Writing this parser was my first encouter
with recursion! Here's the code:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span class="c"># ---- PARSER ----- def parse(to</span>
<span class="n">kens</span><span class="p">):</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="k">raise</span> <span class="n">unexpected_error</span>    <span class="n">token</span> <span class="o">=</span>
<span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="s">&#39;(&#39;</span><span class="p">:</span>        <span class="n">parsed_input</span>
<span class="o">=</span> <span class="p">[]</span>         <span class="k">while</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;)&#39;</span>
<span class="p">:</span>            <span class="n">to_append</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">par</span>
<span class="n">se</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>            <span class="n">parsed_input</span><span class="o">.</span><span class="n">a</span>
<span class="n">ppend</span><span class="p">(</span><span class="n">to_append</span><span class="p">)</span>        <span class="n">tokens</span> <span class="o">=</span> <span class="n">tok</span>
<span class="n">ens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>                 <span class="c">#pops off th</span>
<span class="n">e</span> <span class="s">&#39;)&#39;</span> <span class="n">part</span>        <span class="c">#we add a conditio</span>
<span class="n">n</span> <span class="n">to</span> <span class="n">check</span> <span class="k">if</span> <span class="n">last</span> <span class="k">return</span>        <span class="k">if</span>
<span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>            <span class="k">return</span> <span class="n">p</span>
<span class="n">arsed_input</span><span class="p">,</span> <span class="n">tokens</span>     <span class="c">#if not last</span>
<span class="k">return</span><span class="p">,</span> <span class="n">need</span> <span class="n">to</span> <span class="k">return</span> <span class="n">current</span> <span class="n">vers</span>
<span class="n">ion</span> <span class="n">of</span> <span class="n">tokens</span>        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span>
<span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>            <span class="k">return</span> <span class="n">parsed_in</span>
<span class="n">put</span>             <span class="c">#if last return, onl</span>
<span class="n">y</span> <span class="n">want</span> <span class="n">to</span> <span class="k">return</span> <span class="n">new</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">tokens</span>
<span class="k">else</span><span class="p">:</span>        <span class="k">return</span> <span class="n">chec</span>
<span class="n">k_type</span><span class="p">(</span><span class="n">token</span><span class="p">),</span> <span class="n">tokens</span>
</pre></div>
</td></tr></table>

<p>To better understand this function, lets look at how
<code>parse(['(', '(', +, '1', '1', ')', ')'])</code> would be processed, line by
line. Line 3 is not satisfied, so we skip to line 6 and 7. Here Token
will be set to <code>'('</code>, tokens will become
<code>[ '(', '+', '1', '1', ')', ')']</code>. Since the condition on line 9 is
satisfied, we then enter this branch and continue on with line 10 where
<code>parsed_input</code> is initialized as an empty list. Then we enter the while
loop on line 12, and in line 13 we recurse back into our parse function
by calling <code>parse(tokens)</code>.</p>
<p>Now in the second level of our parse function. In this level we execute
line 6 and 7 again, setting <code>token</code> as <code>'('</code>, and <code>tokens</code> to
<code>['+', '1', '1',')', ')']</code>. Since <code>token</code> is still <code>'('</code>, line 10 will
again be executed, creating another <code>parsed_input</code> list, and then diving
into our 3rd level of recursion on <code>parse</code>.</p>
<p>In this 3rd level, token is <code>'+'</code> and tokens is <code>['1', '1', ')', ')']</code>.
Since token is not <code>'('</code> we skip down to the else condition and execute
line 23. Since we have yet to define the function check_type, just
pretend that this line returns token and tokens. Having returned those
values, we come out of the 3rd layer of recursion and back into the 2nd,
at line 13. Here, <code>to_append</code> is set to '+', and tokens is
<code>['1', '1', ')', ')']</code>. Line 14 is then executed, and <code>parsed_input</code>
becomes <code>['+']</code>. We continue looping through this while loop, going into
a 3rd layer of recursion, coming back into two, and appending
<code>parsed_input</code> until <code>parsed_input</code> looks like ['+', '1', '1'] in our
second layer of recursion. At this point the tokens[0] will be ')', so
we break out of the while loop. Line 15 remouves ')' from tokens,
leaving tokens as [')']. Then since the length of tokens is positive
line 19 is executed.</p>
<p>Now we exit the second layer of recursion and are back into the first
parse call. <code>to_append</code> becomes <code>['+', '1', '1']</code>, and <code>tokens</code> is
<code>[')']</code>. The original <code>parsed_input</code> is updated to <code>[['+', '1', '1']]</code>,
the while loop ends, and line 15 is executed, changing <code>tokens</code> to <code>[]</code>.
Since the <code>len(tokens)</code> is zero line 20 is executed and <code>parsed_input</code>
is the final return. We have exited all levels of the parse function,
effectively parsing the input!</p>
<p>This blog post will be continued... I have written enough for one day.</p>
<p class="subheader">Category: <a href="http://lmontopo.github.io/category/blog.html">Blog</a>

</p>




</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://lmontopo.github.io/archives.html">Archives</a>
            <li><a href="http://lmontopo.github.io/tags.html">Tags</a>
        </ul>

		
        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://lmontopo.github.io/category/blog.html">Blog</a></li>
   
        </ul>

		

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>The L Blog by Leta Montopoli</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>